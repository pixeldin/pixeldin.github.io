<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.80.0 with theme Tranquilpeak 0.4.8-BETA">
<meta name="author" content="pixelpig">
<meta name="keywords" content="">
<meta name="description" content="前言: Gin的词源是金酒, 又称琴酒, 是来自荷兰的一种烈性酒。">


<meta property="og:description" content="前言: Gin的词源是金酒, 又称琴酒, 是来自荷兰的一种烈性酒。">
<meta property="og:type" content="article">
<meta property="og:title" content="聊一聊Gin Web框架之前，看一眼httprouter">
<meta name="twitter:title" content="聊一聊Gin Web框架之前，看一眼httprouter">
<meta property="og:url" content="/2020/05/%E8%81%8A%E4%B8%80%E8%81%8Agin-web%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%89%8D%E7%9C%8B%E4%B8%80%E7%9C%BChttprouter/">
<meta property="twitter:url" content="/2020/05/%E8%81%8A%E4%B8%80%E8%81%8Agin-web%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%89%8D%E7%9C%8B%E4%B8%80%E7%9C%BChttprouter/">
<meta property="og:site_name" content="Pixelpig&#39;s blog">
<meta property="og:description" content="前言: Gin的词源是金酒, 又称琴酒, 是来自荷兰的一种烈性酒。">
<meta name="twitter:description" content="前言: Gin的词源是金酒, 又称琴酒, 是来自荷兰的一种烈性酒。">
<meta property="og:locale" content="zh-cn">

  
    <meta property="article:published_time" content="2020-05-16T00:00:00">
  
  
    <meta property="article:modified_time" content="2020-05-16T00:00:00">
  
  
  
    
      <meta property="article:section" content="Go">
    
      <meta property="article:section" content="网络编程">
    
  
  
    
      <meta property="article:tag" content="Gin">
    
  


<meta name="twitter:card" content="summary">







  <meta property="og:image" content="https://pixelpig-1253685321.cos.ap-guangzhou.myqcloud.com/go-context.jpg">
  <meta property="twitter:image" content="https://pixelpig-1253685321.cos.ap-guangzhou.myqcloud.com/go-context.jpg">





  <meta property="og:image" content="https://pixelpig-1253685321.cos.ap-guangzhou.myqcloud.com/pig.jpg">
  <meta property="twitter:image" content="https://pixelpig-1253685321.cos.ap-guangzhou.myqcloud.com/pig.jpg">


    <title>聊一聊Gin Web框架之前，看一眼httprouter</title>

    <link rel="icon" href="/favicon.png">
    

    

    <link rel="canonical" href="/2020/05/%E8%81%8A%E4%B8%80%E8%81%8Agin-web%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%89%8D%E7%9C%8B%E4%B8%80%E7%9C%BChttprouter/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="5">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="/">Pixelpig&#39;s blog</a>
  </div>
  
    
      <a class="header-right-picture "
         href="/#about">
    
    
    
      
        <img class="header-picture" src="https://pixelpig-1253685321.cos.ap-guangzhou.myqcloud.com/pig.jpg" alt="作者的图片" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="5">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="/#about">
          <img class="sidebar-profile-picture" src="https://pixelpig-1253685321.cos.ap-guangzhou.myqcloud.com/pig.jpg" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">pixelpig</h4>
        
          <h5 class="sidebar-profile-bio">Stay hungry, stay foolish <strong>:）</strong></h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">分类</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">归档</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/https://github.com/pixeldin">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="5"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      聊一聊Gin Web框架之前，看一眼httprouter
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2020-05-16T00:00:00Z">
        
  五月 16, 2020

      </time>
    
    
  
  
    <span>发布在</span>
    
      <a class="category-link" href="/categories/go">Go</a>, 
    
      <a class="category-link" href="/categories/%e7%bd%91%e7%bb%9c%e7%bc%96%e7%a8%8b">网络编程</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p>前言: Gin的词源是金酒, 又称琴酒, 是来自荷兰的一种烈性酒。</p>
<p>在Go中，有一个经常提及的<strong>web</strong>框架，就是<strong>gin web</strong>，具备高性能，可灵活定制化的特点，既然它是如此被看好，在深入了解它之前，不妨先看下他是基于什么实现的。</p>
<h2 id="饮酒思源httprouter">饮酒思源：httprouter</h2>
<p>根据Git作者描述，<strong>Gin</strong>的高性能得益于一个叫<strong>httprouter</strong>的框架生成的，顺着源头看，我们先针对<strong>httprouter</strong>， 从<strong>HTTP路由</strong>开始，作为<strong>Gin</strong>框架的引入篇。</p>
<h3 id="route路由">route路由</h3>
<p>在扎堆深入之前， 先梳理一下<strong>路由</strong>的概念：<br>
路由： 大概意思是通过转发数据包实现互联，比如生活中常见的物理路由器，是指内网与外网之间信息流的分配。<br>
同理，软件层面也有路由的概念，一般暴露在业务层之上，用于<strong>转发</strong>请求到合适的逻辑处理器。</p>
<blockquote>
<p>The router matches incoming requests by the request method and the path.</p>
</blockquote>
<p>程序的应用上，常见的如对外服务器把外部请求打到<strong>Nginx网关</strong>，再<strong>路由</strong>(转发)到内部服务或者内部服务的“控制层”，如Java的<strong>springMVC</strong>，Go的原生<strong>router</strong>等对不同请求转发到不同业务层。<br>
或者再具体化点说，比如不同参数调用同名方法，如<strong>Java</strong>的重载，也可以理解为程序根据参数的不同路由到相应不同的方法。</p>
<h3 id="httprouter">httprouter</h3>
<h4 id="功能现象">功能现象：</h4>
<p><strong>Git</strong>的README文档上，<strong>httprouter</strong>开门见山的展示了它的一个常见功能，<br>
启动一个<strong>HTTP</strong>服务器，并且监听8080端口，对请求执行参数解析，仅仅几行代码，当我第一次见到这种实现时候，确实觉得<strong>go</strong>这种实现相当优雅。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">router</span>.<span style="color:#a6e22e">GET</span>(<span style="color:#e6db74">&#34;/&#34;</span>, <span style="color:#a6e22e">Index</span>)
<span style="color:#75715e">//传入参数name
</span><span style="color:#75715e"></span><span style="color:#a6e22e">router</span>.<span style="color:#a6e22e">GET</span>(<span style="color:#e6db74">&#34;/hello/:name&#34;</span>, <span style="color:#a6e22e">Hello</span>)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Hello</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
    <span style="color:#75715e">//通过http.Request结构的上下文可以拿到请求url所带的参数
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">params</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">httprouter</span>.<span style="color:#a6e22e">ParamsFromContext</span>(<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Context</span>())
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Fprintf</span>(<span style="color:#a6e22e">w</span>, <span style="color:#e6db74">&#34;hello, %s!\n&#34;</span>, <span style="color:#a6e22e">params</span>.<span style="color:#a6e22e">ByName</span>(<span style="color:#e6db74">&#34;name&#34;</span>))
}

<span style="color:#75715e">//启动监听
</span><span style="color:#75715e"></span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ListenAndServe</span>(<span style="color:#e6db74">&#34;:8080&#34;</span>, <span style="color:#a6e22e">router</span>)

</code></pre></div><hr>
<h3 id="接口实现">接口实现</h3>
<p>在观察了如何建立一个监听程序之后，挖掘这种优雅是如何封装实现之前，我们要先了解，在原生<strong>Go</strong>中，每个<code>Router</code>路由结构都实现了<code>http.Handler</code>接口，<code>Handler</code>只有一个方法体，就是<code>ServerHTTP</code>，它只有一个功能，就是处理请求，做出响应。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Handler</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">ServeHTTP</span>(<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">Request</span>)
}
</code></pre></div><p>题外话，<strong>Go</strong>中比较倾向于<strong>KISS</strong>或者单一职责，把每个接口的功能都单一化，有需要再进行组合，用组合代替继承，后续会把它当作一个编码规范来看。</p>
<h4 id="nethttpserver">net\http\server</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// The HandlerFunc type is an adapter to allow the use of
</span><span style="color:#75715e">// ordinary functions as HTTP handlers. If f is a function
</span><span style="color:#75715e">// with the appropriate signature, HandlerFunc(f) is a
</span><span style="color:#75715e">// Handler that calls f.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">HandlerFunc</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">Request</span>)

<span style="color:#75715e">// ServeHTTP calls f(w, r).
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#a6e22e">HandlerFunc</span>) <span style="color:#a6e22e">ServeHTTP</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Request</span>) {
	<span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">r</span>)
}
</code></pre></div><p>可以看到，在<code>Go</code>原生库中，<code>ServeHTTP()</code>实现体<code>HandlerFunc</code>就是个func函数类型，具体实现又是直接套用<code>HandlerFunc</code>进行处理，我没有在套娃哈，是不是有种“我实现我自己”的赶脚。</p>
<p>All in all, 我们先抛开第三方库的封装，复习一下标准库，假如我们想用原生<strong>http\server</strong>包搭建一个HTTP处理逻辑，我们一般可以<br>
方式1：</p>
<ol>
<li>定义一个参数列表是（ResponseWriter, *Request）的函数</li>
<li>将其注册到<code>http.Server</code>作为其<code>Handler</code>成员</li>
<li>调用<strong>ListenAndServer</strong>对<strong>http.Server</strong>进行监听</li>
</ol>
<p>方式2：</p>
<ol>
<li>定义一个结构，并且实现接口<code>ServeHTTP(w http.ResponseWriter, req *http.Request)</code></li>
<li>将其注册到<code>http.Server</code>作为其<code>Handler</code>成员</li>
<li>调用<strong>ListenAndServer</strong>对<strong>http.Server</strong>进行监听</li>
</ol>
<p><strong>示例如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//方式1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">SelfHandler</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Fprint</span>(<span style="color:#a6e22e">w</span>, <span style="color:#e6db74">&#34;&lt;h1&gt;Hello!&lt;/h1&gt;&#34;</span>)
}

<span style="color:#75715e">//方式2
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">HelloHandler</span> <span style="color:#66d9ef">struct</span> {
}
<span style="color:#75715e">//HelloHandler实现ServeHTTP()接口
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span> <span style="color:#a6e22e">HelloHandler</span>) <span style="color:#a6e22e">ServeHTTP</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">req</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Fprint</span>(<span style="color:#a6e22e">w</span>, <span style="color:#e6db74">&#34;&lt;h1&gt;Hello!&lt;/h1&gt;&#34;</span>)
}

<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Server</span>{
	<span style="color:#a6e22e">Addr</span>:           <span style="color:#e6db74">&#34;:8080&#34;</span>,
	<span style="color:#75715e">//方式1
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Handler</span>:        <span style="color:#a6e22e">SelfHandler</span>,
	<span style="color:#75715e">//方式2
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//Handler:      &amp;HelloHandler{},
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ReadTimeout</span>:    <span style="color:#ae81ff">10</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>,
	<span style="color:#a6e22e">WriteTimeout</span>:   <span style="color:#ae81ff">10</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>,
	<span style="color:#a6e22e">MaxHeaderBytes</span>: <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">20</span>,
}
<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">ListenAndServe</span>()
</code></pre></div><p><strong>抛砖引玉：</strong><br>
以上就是<strong>Go</strong>标准库实现http服务的常用用法，现在进行拓展，假如我们需要通过url去获取参数，如<strong>Get</strong>请求，<code>localhost:8080/abc/1</code>
Q： 我们如何拿到abc或者1呢？<br>
A： 其实有个相对粗暴的方法，就是硬解：</p>
<ul>
<li>利用<code>net/url</code>的<code>Parse()</code>函数把<code>8080</code>后面的那一段提取出来</li>
<li>使用<code>stings.split(ul, &quot;/&quot;)</code></li>
<li>利用下标进行参数范围</li>
</ul>
<p><strong>示例如下</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestStartHelloWithHttp</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>)  {
	<span style="color:#75715e">//fmt.Println(path.Base(ul))
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">ul</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">`https://localhost:8080/pixeldin/123`</span>
	<span style="color:#a6e22e">parse</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">url</span>.<span style="color:#a6e22e">Parse</span>(<span style="color:#a6e22e">ul</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalf</span>(<span style="color:#e6db74">&#34;%v&#34;</span>, <span style="color:#a6e22e">e</span>)
	}
	<span style="color:#75715e">//fmt.Println(parse.Path)	// &#34;/pixeldin/123&#34;
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">name</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">GetParamFromUrl</span>(<span style="color:#a6e22e">parse</span>.<span style="color:#a6e22e">Path</span>, <span style="color:#ae81ff">1</span>)
	<span style="color:#a6e22e">id</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">GetParamFromUrl</span>(<span style="color:#a6e22e">parse</span>.<span style="color:#a6e22e">Path</span>, <span style="color:#ae81ff">2</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;name: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">name</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, id: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">id</span>)	
}

<span style="color:#75715e">//指定下标返回相对url的值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">GetParamFromUrl</span>(<span style="color:#a6e22e">base</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">index</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">ps</span> <span style="color:#66d9ef">string</span>) {
	<span style="color:#a6e22e">kv</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">base</span>, <span style="color:#e6db74">&#34;/&#34;</span>)
	<span style="color:#a6e22e">assert</span>(<span style="color:#a6e22e">index</span> &lt; len(<span style="color:#a6e22e">kv</span>), <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;index out of range.&#34;</span>))
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">kv</span>[<span style="color:#a6e22e">index</span>]
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">assert</span>(<span style="color:#a6e22e">ok</span> <span style="color:#66d9ef">bool</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)  {
	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
		panic(<span style="color:#a6e22e">err</span>)
	}
}
</code></pre></div><p><strong>输出：</strong></p>
<pre><code>name: pixeldin, id: 123
</code></pre><p>这种办法给人感觉相当暴力，而且需要记住每个参数的位置和对应的值，并且多个url不能统一管理起来，每次寻址都是遍历。尽管Go标准库也提供了一些通用函数，比如下面这个栗子：<br>
<strong>GET</strong>方式的url: <code>https://localhost:8080/?key=hello</code>,<br>
可以通过<code>*http.Request</code>来获取，这种请求方式是在url中声明键值对，然后后台根据请求key进行提取。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//摘取自：https://golangcode.com/get-a-url-parameter-from-a-request/
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">handler</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {

    <span style="color:#a6e22e">keys</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">URL</span>.<span style="color:#a6e22e">Query</span>()[<span style="color:#e6db74">&#34;key&#34;</span>]
    
    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> <span style="color:#f92672">||</span> len(<span style="color:#a6e22e">keys</span>[<span style="color:#ae81ff">0</span>]) &lt; <span style="color:#ae81ff">1</span> {
        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Url Param &#39;key&#39; is missing&#34;</span>)
        <span style="color:#66d9ef">return</span>
    }

    <span style="color:#75715e">// Query()[&#34;key&#34;] will return an array of items, 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// we only want the single item.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">keys</span>[<span style="color:#ae81ff">0</span>]

    <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Url Param &#39;key&#39; is: &#34;</span> <span style="color:#f92672">+</span> string(<span style="color:#a6e22e">key</span>))
}
</code></pre></div><p>但是，曾经沧海难为水。相信大家更喜欢开篇列举的那个例子，包括现在我们习惯的几个主流的框架，都倾向于利用url的位置去寻参，当然<code>httprouter</code>的优势肯定不止在这里，这里只是作为一个了解<code>httprouter</code>的切入点。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">router</span>.<span style="color:#a6e22e">GET</span>(<span style="color:#e6db74">&#34;/hello/:name&#34;</span>, <span style="color:#a6e22e">Hello</span>)
<span style="color:#a6e22e">router</span>.<span style="color:#a6e22e">GET</span>(<span style="color:#e6db74">&#34;/hello/*name&#34;</span>, <span style="color:#a6e22e">HelloWorld</span>)
</code></pre></div><p>到这里先止住，后续我们来追踪它们封装之后的底层实现以及是如何规划url参数的。</p>
<hr>
<h3 id="httprouter对serverhttp的实现">httprouter对ServerHTTP()的实现</h3>
<p>前面提到，所有路由结构都实现了<code>http.Handler</code>接口的<code>ServeHTTP()</code>方法，我们来看下<code>httprouter</code>基于它的实现方式。</p>
<h4 id="julienschmidthttprouter">julienschmidt\httprouter</h4>
<p>在<strong>httprouter</strong>中，<strong>ServeHTTP()</strong> 的实现结构就叫<code>*Router</code>，它内部封装了用于检索url的tree结构，几个常用的布尔选项，还有几个也是基于<code>http.Handler</code>实现的默认处理器，它的实现如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// ServeHTTP makes the router implement the http.Handler interface.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Router</span>) <span style="color:#a6e22e">ServeHTTP</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">req</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">PanicHandler</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">recv</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">req</span>)
	}

	<span style="color:#a6e22e">path</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">URL</span>.<span style="color:#a6e22e">Path</span>

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">trees</span>[<span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">Method</span>]; <span style="color:#a6e22e">root</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
	    <span style="color:#75715e">//getValue()返回处理方法与参数列表
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">handle</span>, <span style="color:#a6e22e">ps</span>, <span style="color:#a6e22e">tsr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">getValue</span>(<span style="color:#a6e22e">path</span>); <span style="color:#a6e22e">handle</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		    <span style="color:#75715e">//匹配执行
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">handle</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">req</span>, <span style="color:#a6e22e">ps</span>)
			<span style="color:#66d9ef">return</span>
		} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">Method</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">MethodConnect</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">path</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;/&#34;</span> {
			<span style="color:#75715e">//...
</span><span style="color:#75715e"></span>		}
	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">Method</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">MethodOptions</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">HandleOPTIONS</span> {
		<span style="color:#75715e">// Handle OPTIONS requests
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//...
</span><span style="color:#75715e"></span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">HandleMethodNotAllowed</span> { <span style="color:#75715e">// Handle 405
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//执行默认处理器...
</span><span style="color:#75715e"></span>	}

	<span style="color:#75715e">// Handle 404
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">NotFound</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">NotFound</span>.<span style="color:#a6e22e">ServeHTTP</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">req</span>)
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">NotFound</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">req</span>)
	}
}
</code></pre></div><p>到这里可以大致猜测它把处理method注入到内部trees结构，利用传入url在trees进行匹配查找，对执行链进行相应执行。
可以猜测这个<code>Router.trees</code>包含了handle和相应的参数，接着我们进入它的路由索引功能，来看下它是怎么实现++url匹配++与++参数解析++的。</p>
<p><strong>结构梳理：</strong><br>
这个<code>trees</code>存在tree.go源文件中，其实是个map键值对，<br>
key是<strong>HTTP methods</strong>(如GET/HEAD/POST/PUT等)，method就是当前method与方法绑定上的节点</p>
<p>我在源码补充些注释，相信大家容易看懂。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Handle registers a new request handle with the given path and method.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// For GET, POST, PUT, PATCH and DELETE requests the respective shortcut
</span><span style="color:#75715e">// functions can be used.
</span><span style="color:#75715e">// ...
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Router</span>) <span style="color:#a6e22e">Handle</span>(<span style="color:#a6e22e">method</span>, <span style="color:#a6e22e">path</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">handle</span> <span style="color:#a6e22e">Handle</span>) {
	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">path</span>) &lt; <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">path</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;/&#39;</span> {
		panic(<span style="color:#e6db74">&#34;path must begin with &#39;/&#39; in path &#39;&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">path</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#39;&#34;</span>)
	}

    <span style="color:#75715e">//首次注册url，初始化trees
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">trees</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">trees</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">node</span>)
	}

    <span style="color:#75715e">//绑定http methods根节点，method可以是GET/POST/PUT等
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">root</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">trees</span>[<span style="color:#a6e22e">method</span>]
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">root</span> = new(<span style="color:#a6e22e">node</span>)
		<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">trees</span>[<span style="color:#a6e22e">method</span>] = <span style="color:#a6e22e">root</span>

		<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">globalAllowed</span> = <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">allowed</span>(<span style="color:#e6db74">&#34;*&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>)
	}
    
    <span style="color:#75715e">//对http methods方法树的路径划分
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">addRoute</span>(<span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">handle</span>)
}
</code></pre></div><p><code>Router.trees</code>map键值对的value是一个<code>node</code>结构体，每个<strong>HTTP METHOD</strong> 都是一个root节点，最主要的path分配是在这些节点的<strong>addRoute()</strong> 函数，<br>
简单理解的话, 最终那些前缀一致的路径会被绑定到这个树的同一个分支方向上，直接提高了索引的效率。</p>
<p>下面我先列举出<code>node</code>几个比较重要的成员：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">node</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">path</span>      <span style="color:#66d9ef">string</span>
	<span style="color:#75715e">//标识 path是否后续有&#39;:&#39;, 用于参数判断
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">wildChild</span> <span style="color:#66d9ef">bool</span>
	<span style="color:#75715e">/* 当前节点的类型，默认是0，
</span><span style="color:#75715e">	(root/param/catchAll)分别标识（根/有参数/全路径）*/</span>
	<span style="color:#a6e22e">nType</span>     <span style="color:#a6e22e">nodeType</span>
	<span style="color:#a6e22e">maxParams</span> <span style="color:#66d9ef">uint8</span>
	<span style="color:#75715e">//当前节点优先级, 挂在上面的子节点越多,优先级越高
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">priority</span>  <span style="color:#66d9ef">uint32</span>
	<span style="color:#a6e22e">indices</span>   <span style="color:#66d9ef">string</span>
	<span style="color:#75715e">//满足前缀的子节点,可以延申
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">children</span>  []<span style="color:#f92672">*</span><span style="color:#a6e22e">node</span>
	<span style="color:#75715e">//与当前节点绑定的处理逻辑块
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">handle</span>    <span style="color:#a6e22e">Handle</span>
}
</code></pre></div><p>其中子节点越多，或者说绑定handle方法越多的根节点，<strong>priority</strong>优先级越高，作者有意识的对每次注册完成进行优先级排序。
引用作者的批注:</p>
<blockquote>
<p>This helps in two ways:</p>
<ul>
<li>Nodes which are part of the most routing paths are evaluated first. This helps to make as much routes as possible to be reachable as fast as possible.</li>
<li>It is some sort of cost compensation. The longest reachable path (highest cost) can always be evaluated first. The following scheme visualizes the tree structure. Nodes are evaluated from top to bottom and from left to right.</li>
</ul>
</blockquote>
<p>优先级高的节点有利于handle的快速定位，相信比较好理解，现实中人流量密集处往往就是十字路口，类似交通枢纽。基于前缀树的匹配，让寻址从密集处开始，有助于提高效率。</p>
<p><strong>由浅入深：</strong><br>
我们先给路由器router注册几个作者提供的GET处理逻辑，然后开始调试，看下这个trees成员随着url新增有什么变化，</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">router</span>.<span style="color:#a6e22e">Handle</span>(<span style="color:#e6db74">&#34;GET&#34;</span>, <span style="color:#e6db74">&#34;/user/ab/&#34;</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>, <span style="color:#a6e22e">ps</span> <span style="color:#a6e22e">httprouter</span>.<span style="color:#a6e22e">Params</span>) {
	<span style="color:#75715e">//do nothing, just add path+handler
</span><span style="color:#75715e"></span>})

<span style="color:#a6e22e">router</span>.<span style="color:#a6e22e">Handle</span>(<span style="color:#e6db74">&#34;GET&#34;</span>, <span style="color:#e6db74">&#34;/user/abc/&#34;</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>, <span style="color:#a6e22e">ps</span> <span style="color:#a6e22e">httprouter</span>.<span style="color:#a6e22e">Params</span>) {
	<span style="color:#75715e">//do nothing, just add path+handler
</span><span style="color:#75715e"></span>})

<span style="color:#a6e22e">router</span>.<span style="color:#a6e22e">Handle</span>(<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">MethodGet</span>, <span style="color:#e6db74">&#34;/user/query/:name&#34;</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>, <span style="color:#a6e22e">ps</span> <span style="color:#a6e22e">httprouter</span>.<span style="color:#a6e22e">Params</span>) {
	<span style="color:#a6e22e">routed</span> = <span style="color:#66d9ef">true</span>
	<span style="color:#a6e22e">want</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">httprouter</span>.<span style="color:#a6e22e">Params</span>{<span style="color:#a6e22e">httprouter</span>.<span style="color:#a6e22e">Param</span>{<span style="color:#e6db74">&#34;name&#34;</span>, <span style="color:#e6db74">&#34;gopher&#34;</span>}}
	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">DeepEqual</span>(<span style="color:#a6e22e">ps</span>, <span style="color:#a6e22e">want</span>) {
		<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Fatalf</span>(<span style="color:#e6db74">&#34;wrong wildcard values: want %v, got %v&#34;</span>, <span style="color:#a6e22e">want</span>, <span style="color:#a6e22e">ps</span>)
	}
})
</code></pre></div><p>上述操作把【<strong>RESTful的GET方法</strong>，<strong>url路径</strong>，<strong>匿名函数handler</strong>】作为<code>router.Handler()</code>的参数，<code>router.Handler()</code>的操作上面我们已经简单的分析过了，主要节点划分在其中的<code>addRoute()</code>函数里面，下面我们简单过一下它的逻辑</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 将当前url与处理逻辑放在当前节点
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">n</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">node</span>) <span style="color:#a6e22e">addRoute</span>(<span style="color:#a6e22e">path</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">handle</span> <span style="color:#a6e22e">Handle</span>) {
	<span style="color:#a6e22e">fullPath</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">path</span>
	<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">priority</span><span style="color:#f92672">++</span>
	<span style="color:#75715e">//提取当前url参数个数
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">numParams</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">countParams</span>(<span style="color:#a6e22e">path</span>)

	<span style="color:#75715e">// 如果当前节点已经存在注册链路
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">path</span>) &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> len(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">children</span>) &gt; <span style="color:#ae81ff">0</span> {
	<span style="color:#a6e22e">walk</span>:
		<span style="color:#66d9ef">for</span> {
			<span style="color:#75715e">// 更新最大参数个数
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">numParams</span> &gt; <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">maxParams</span> {
				<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">maxParams</span> = <span style="color:#a6e22e">numParams</span>
			}

			<span style="color:#75715e">// 判断待注册url是否与已有url有重合，提取重合的最长下标
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// This also implies that the common prefix contains no &#39;:&#39; or &#39;*&#39;
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// since the existing key can&#39;t contain those chars.
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
			<span style="color:#a6e22e">max</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">min</span>(len(<span style="color:#a6e22e">path</span>), len(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">path</span>))
			<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">max</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">path</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">path</span>[<span style="color:#a6e22e">i</span>] {
				<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
			}

			<span style="color:#75715e">/*
</span><span style="color:#75715e">			    如果进来的url匹配长度大于于当前节点已有的url，则创建子节点
</span><span style="color:#75715e">			    比如当前节点是/user/ab/ func1，
</span><span style="color:#75715e">			    
</span><span style="color:#75715e">			    新进来一个/user/abc/ func2，则需要创建/user/ab的子节点/ 和 c/
</span><span style="color:#75715e">			    树状如下：
</span><span style="color:#75715e">        			    |-/user/ab
</span><span style="color:#75715e">        			    |--------|-/ func1  
</span><span style="color:#75715e">        			    |--------|-c/ func2
</span><span style="color:#75715e">        			    
</span><span style="color:#75715e">			    之后如果再注册一个/user/a/ 与func3
</span><span style="color:#75715e">			    则最终树会调整为：
</span><span style="color:#75715e">        		优先级3 |-/user/a 
</span><span style="color:#75715e">        		优先级2 |--------|-b 
</span><span style="color:#75715e">        		优先级1 |----------|-/ func1
</span><span style="color:#75715e">        		优先级1 |----------|-c/ func2
</span><span style="color:#75715e">        		优先级1 |--------|-/ func3
</span><span style="color:#75715e">			    
</span><span style="color:#75715e">		    */</span>
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">path</span>) {
				<span style="color:#a6e22e">child</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">node</span>{
					<span style="color:#a6e22e">path</span>:      <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">path</span>[<span style="color:#a6e22e">i</span>:],
					<span style="color:#a6e22e">wildChild</span>: <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">wildChild</span>,
					<span style="color:#a6e22e">nType</span>:     <span style="color:#a6e22e">static</span>,
					<span style="color:#a6e22e">indices</span>:   <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">indices</span>,
					<span style="color:#a6e22e">children</span>:  <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">children</span>,
					<span style="color:#a6e22e">handle</span>:    <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">handle</span>,
					<span style="color:#a6e22e">priority</span>:  <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">priority</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>,
				}

				<span style="color:#75715e">// 遍历子节点，取最高优先级作为父节点优先级
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">child</span>.<span style="color:#a6e22e">children</span> {
					<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">child</span>.<span style="color:#a6e22e">children</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">maxParams</span> &gt; <span style="color:#a6e22e">child</span>.<span style="color:#a6e22e">maxParams</span> {
						<span style="color:#a6e22e">child</span>.<span style="color:#a6e22e">maxParams</span> = <span style="color:#a6e22e">child</span>.<span style="color:#a6e22e">children</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">maxParams</span>
					}
				}

				<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">children</span> = []<span style="color:#f92672">*</span><span style="color:#a6e22e">node</span>{<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">child</span>}
				<span style="color:#75715e">// []byte for proper unicode char conversion, see #65
</span><span style="color:#75715e"></span>				<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">indices</span> = string([]<span style="color:#66d9ef">byte</span>{<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">path</span>[<span style="color:#a6e22e">i</span>]})
				<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">path</span> = <span style="color:#a6e22e">path</span>[:<span style="color:#a6e22e">i</span>]
				<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">handle</span> = <span style="color:#66d9ef">nil</span>
				<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">wildChild</span> = <span style="color:#66d9ef">false</span>
			}

			<span style="color:#75715e">// Make new node a child of this node
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">path</span>) {
				<span style="color:#a6e22e">path</span> = <span style="color:#a6e22e">path</span>[<span style="color:#a6e22e">i</span>:]

				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">wildChild</span> {
					<span style="color:#a6e22e">n</span> = <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">children</span>[<span style="color:#ae81ff">0</span>]
					<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">priority</span><span style="color:#f92672">++</span>

					<span style="color:#75715e">// Update maxParams of the child node
</span><span style="color:#75715e"></span>					<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">numParams</span> &gt; <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">maxParams</span> {
						<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">maxParams</span> = <span style="color:#a6e22e">numParams</span>
					}
					<span style="color:#a6e22e">numParams</span><span style="color:#f92672">--</span>

					<span style="color:#75715e">// Check if the wildcard matches
</span><span style="color:#75715e"></span>					<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">path</span>) <span style="color:#f92672">&gt;=</span> len(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">path</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">path</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">path</span>[:len(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">path</span>)] <span style="color:#f92672">&amp;&amp;</span>
						<span style="color:#75715e">// Adding a child to a catchAll is not possible
</span><span style="color:#75715e"></span>						<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">nType</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">catchAll</span> <span style="color:#f92672">&amp;&amp;</span>
						<span style="color:#75715e">// Check for longer wildcard, e.g. :name and :names
</span><span style="color:#75715e"></span>						(len(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">path</span>) <span style="color:#f92672">&gt;=</span> len(<span style="color:#a6e22e">path</span>) <span style="color:#f92672">||</span> <span style="color:#a6e22e">path</span>[len(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">path</span>)] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;/&#39;</span>) {
						<span style="color:#66d9ef">continue</span> <span style="color:#a6e22e">walk</span>
					} <span style="color:#66d9ef">else</span> {
						<span style="color:#75715e">// Wildcard conflict
</span><span style="color:#75715e"></span>						<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">pathSeg</span> <span style="color:#66d9ef">string</span>
						<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">nType</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">catchAll</span> {
							<span style="color:#a6e22e">pathSeg</span> = <span style="color:#a6e22e">path</span>
						} <span style="color:#66d9ef">else</span> {
							<span style="color:#a6e22e">pathSeg</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">SplitN</span>(<span style="color:#a6e22e">path</span>, <span style="color:#e6db74">&#34;/&#34;</span>, <span style="color:#ae81ff">2</span>)[<span style="color:#ae81ff">0</span>]
						}
						<span style="color:#a6e22e">prefix</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fullPath</span>[:<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Index</span>(<span style="color:#a6e22e">fullPath</span>, <span style="color:#a6e22e">pathSeg</span>)] <span style="color:#f92672">+</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">path</span>
						panic(<span style="color:#e6db74">&#34;&#39;&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">pathSeg</span> <span style="color:#f92672">+</span>
							<span style="color:#e6db74">&#34;&#39; in new path &#39;&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">fullPath</span> <span style="color:#f92672">+</span>
							<span style="color:#e6db74">&#34;&#39; conflicts with existing wildcard &#39;&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">path</span> <span style="color:#f92672">+</span>
							<span style="color:#e6db74">&#34;&#39; in existing prefix &#39;&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">prefix</span> <span style="color:#f92672">+</span>
							<span style="color:#e6db74">&#34;&#39;&#34;</span>)
					}
				}

				<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">path</span>[<span style="color:#ae81ff">0</span>]

				<span style="color:#75715e">// slash after param
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">nType</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">param</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;/&#39;</span> <span style="color:#f92672">&amp;&amp;</span> len(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">children</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
					<span style="color:#a6e22e">n</span> = <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">children</span>[<span style="color:#ae81ff">0</span>]
					<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">priority</span><span style="color:#f92672">++</span>
					<span style="color:#66d9ef">continue</span> <span style="color:#a6e22e">walk</span>
				}

				<span style="color:#75715e">// Check if a child with the next path byte exists
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">indices</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
					<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">indices</span>[<span style="color:#a6e22e">i</span>] {
					    <span style="color:#75715e">//增加当前节点的优先级，并且做出位置调整
</span><span style="color:#75715e"></span>						<span style="color:#a6e22e">i</span> = <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">incrementChildPrio</span>(<span style="color:#a6e22e">i</span>)
						<span style="color:#a6e22e">n</span> = <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">children</span>[<span style="color:#a6e22e">i</span>]
						<span style="color:#66d9ef">continue</span> <span style="color:#a6e22e">walk</span>
					}
				}

				<span style="color:#75715e">// Otherwise insert it
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;*&#39;</span> {
					<span style="color:#75715e">// []byte for proper unicode char conversion, see #65
</span><span style="color:#75715e"></span>					<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">indices</span> <span style="color:#f92672">+=</span> string([]<span style="color:#66d9ef">byte</span>{<span style="color:#a6e22e">c</span>})
					<span style="color:#a6e22e">child</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">node</span>{
						<span style="color:#a6e22e">maxParams</span>: <span style="color:#a6e22e">numParams</span>,
					}
					<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">children</span> = append(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">children</span>, <span style="color:#a6e22e">child</span>)
					<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">incrementChildPrio</span>(len(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">indices</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
					<span style="color:#a6e22e">n</span> = <span style="color:#a6e22e">child</span>
				}
				<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">insertChild</span>(<span style="color:#a6e22e">numParams</span>, <span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">fullPath</span>, <span style="color:#a6e22e">handle</span>)
				<span style="color:#66d9ef">return</span>

			} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> len(<span style="color:#a6e22e">path</span>) { <span style="color:#75715e">// Make node a (in-path) leaf
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">handle</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
					panic(<span style="color:#e6db74">&#34;a handle is already registered for path &#39;&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">fullPath</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#39;&#34;</span>)
				}
				<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">handle</span> = <span style="color:#a6e22e">handle</span>
			}
			<span style="color:#66d9ef">return</span>
		}
	} <span style="color:#66d9ef">else</span> { <span style="color:#75715e">// Empty tree
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">insertChild</span>(<span style="color:#a6e22e">numParams</span>, <span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">fullPath</span>, <span style="color:#a6e22e">handle</span>)
		<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">nType</span> = <span style="color:#a6e22e">root</span>
	}
}
</code></pre></div><p>以上的大致思路是，把各个handle func()注册到一棵url前缀树上面，根据url前缀相同的匹配度进行分支，以提高路由效率。</p>
<p><strong>参数查找：</strong><br>
接下来我们看下<strong>httprouter</strong>是怎么将参数<strong>param</strong>封装在<strong>上下文</strong>里面的：<br>
不难猜测分支划分的时候是通过判断关键字“:”来提取预接收的参数，这些参数是存字符串(字典)键值对，底层存储在一个<code>Param</code>结构体：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Param</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">Key</span>   <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">Value</span> <span style="color:#66d9ef">string</span>
}
</code></pre></div><p>关于上下文的概念在其他语言也挺常见，如<strong>Java Spring</strong>框架中的<code>application-context</code>，用来贯穿程序生命周期，用于管理一些全局属性。<br>
<strong>Go</strong>的上下文也在不同框架有多种实现，这里我们先初步了解Go程序最顶级的上下文是<code>background()</code>，是所有子上下文的来源，类似于Linux系统的init()进程。</p>
<p>先举个栗子，简单列举在<strong>Go</strong>的<strong>context</strong>传参的用法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestContext</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
	<span style="color:#75715e">// 获取顶级上下文
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ctx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>()
	<span style="color:#75715e">// 在上下文写入string值, 注意需要返回新的value上下文
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">valueCtx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">WithValue</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#e6db74">&#34;pixel&#34;</span>)
	<span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">valueCtx</span>.<span style="color:#a6e22e">Value</span>(<span style="color:#e6db74">&#34;hello&#34;</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
	    <span style="color:#75715e">/*
</span><span style="color:#75715e">	        已知写入值是string，所以我们也可以直接进行类型断言
</span><span style="color:#75715e">	        比如： p, _ := ctx.Value(ParamsKey).(Params)
</span><span style="color:#75715e">	        这个下划线其实是go断言返回的bool值
</span><span style="color:#75715e">	    */</span>
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Params type: %v, value: %v.\n&#34;</span>, <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">TypeOf</span>(<span style="color:#a6e22e">value</span>), <span style="color:#a6e22e">value</span>)
	}
}
</code></pre></div><p><strong>输出：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">Params type: string, value: pixel.
</code></pre></div><p>在<strong>httprouter</strong>中，封装在<code>http.request</code>中的上下文其实是个<strong>valueCtx</strong>，类型和我们上面的栗子中<strong>valueCtx</strong>是一样的，框架中提供了一个从上下文获取<strong>Params</strong>键值对的方法，</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ParamsFromContext</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) <span style="color:#a6e22e">Params</span> {
	<span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Value</span>(<span style="color:#a6e22e">ParamsKey</span>).(<span style="color:#a6e22e">Params</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>
}
</code></pre></div><p>利用返回的Params就可以根据key获取我们的目标值了，</p>
<pre><code>params.ByName(key)
</code></pre><p>经过追寻，<strong>Params</strong>是来自一个叫<code>getValue(path string) (handle Handle, p Params, tsr bool)</code>的函数，还记得上面列举的*Router路由实现的<code>ServeHTTP()</code>接口吗？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//ServeHTTP() 函数的一部分
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">trees</span>[<span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">Method</span>]; <span style="color:#a6e22e">root</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#75715e">/**   getValue()，返回处理方法与参数列表  **/</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">handle</span>, <span style="color:#a6e22e">ps</span>, <span style="color:#a6e22e">tsr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">getValue</span>(<span style="color:#a6e22e">path</span>); <span style="color:#a6e22e">handle</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
	    <span style="color:#75715e">//匹配执行， 这里的handle就是上面的匿名函数func
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">handle</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">req</span>, <span style="color:#a6e22e">ps</span>)
		<span style="color:#66d9ef">return</span>
	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">Method</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">MethodConnect</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">path</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;/&#34;</span> {
		<span style="color:#75715e">//...
</span><span style="color:#75715e"></span>	}
}
</code></pre></div><p><code>ServeHTTP()</code>其中有个<code>getValue</code>函数，它的返回值有两个重要成员：当前路由的处理逻辑和url参数列表，所以在路由注册的时候我们需要把params作为入参传进去。
像这样子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">router</span>.<span style="color:#a6e22e">Handle</span>(<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">MethodGet</span>, <span style="color:#e6db74">&#34;/user/query/:name&#34;</span>, 
<span style="color:#75715e">//匿名函数func，这里的ps参数就是在ServeHttp()的时候帮你提取的
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>, <span style="color:#a6e22e">ps</span> <span style="color:#a6e22e">httprouter</span>.<span style="color:#a6e22e">Params</span>) {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">params</span>.<span style="color:#a6e22e">ByName</span>(<span style="color:#e6db74">&#34;name&#34;</span>))
})
</code></pre></div><p><code>getValue()</code>在对当前节点n进行类型判断，如果是‘param’类型(在addRoute的时候已经根据url进行分类)，则填充待返回参数Params。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//-----------go
</span><span style="color:#75715e">//...github.com/julienschmidt/httprouter@v1.3.0/tree.go:367
</span><span style="color:#75715e"></span><span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">nType</span> {
<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">param</span>:
	<span style="color:#75715e">// find param end (either &#39;/&#39; or path end)
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">end</span> &lt; len(<span style="color:#a6e22e">path</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">path</span>[<span style="color:#a6e22e">end</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;/&#39;</span> {
		<span style="color:#a6e22e">end</span><span style="color:#f92672">++</span>
	}
	
    <span style="color:#75715e">//遇到节点参数
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#75715e">// lazy allocation
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">p</span> = make(<span style="color:#a6e22e">Params</span>, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">maxParams</span>)
	}
	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">p</span>)
	<span style="color:#a6e22e">p</span> = <span style="color:#a6e22e">p</span>[:<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#75715e">// expand slice within preallocated capacity
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">p</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">Key</span> = <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">path</span>[<span style="color:#ae81ff">1</span>:]
	<span style="color:#a6e22e">p</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">Value</span> = <span style="color:#a6e22e">path</span>[:<span style="color:#a6e22e">end</span>]
<span style="color:#75715e">//...
</span></code></pre></div><p><strong>流程梳理：</strong><br>
So far，我们再次归纳一下<code>httprouter</code>的路由过程：</p>
<ol>
<li>初始化创建路由器router</li>
<li>注册签名为：<code>type Handle func(http.ResponseWriter, *http.Request, Params)</code>的函数到该router</li>
<li>调用HTTP通用接口<code>ServeHTTP()</code>，用于提取当前url预期的参数并且供业务层使用</li>
</ol>
<hr>
<p>以上这是这两天对httprouter的了解，顺便对<strong>go</strong>的Http有了进一步的认知，后续将尝试进入gin中，看下Gin是基于httprouter做了什么拓展以及熟悉常见用法。</p>
<h3 id="参考链接">参考链接：</h3>
<p><strong>julienschmidt/httprouter</strong><br>
<a href="https://github.com/julienschmidt/httprouter">https://github.com/julienschmidt/httprouter</a></p>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">标签</span><br/>
                    
  <a class="tag tag--primary tag--small" href="/tags/gin/">Gin</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="/2021/01/go%E5%8D%8F%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/" data-tooltip="Go协程间通信之生产者-消费者模型">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="/2020/04/%E8%81%8A%E4%B8%80%E8%81%8Ago%E7%BC%96%E5%86%99%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%B1%BB/" data-tooltip="聊一聊Go编写的命令行工具类">
              
                  <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2021 <a href="https://github.com/pixeldin">pixeldin</a>. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="/2021/01/go%E5%8D%8F%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/" data-tooltip="Go协程间通信之生产者-消费者模型">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="/2020/04/%E8%81%8A%E4%B8%80%E8%81%8Ago%E7%BC%96%E5%86%99%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%B1%BB/" data-tooltip="聊一聊Go编写的命令行工具类">
              
                  <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="5">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://pixelpig-1253685321.cos.ap-guangzhou.myqcloud.com/pig.jpg" alt="作者的图片" />
    
    <h4 id="about-card-name">pixelpig</h4>
    
      <div id="about-card-bio">Stay hungry, stay foolish <strong>:）</strong></div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        后端开发@珠海金山
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        CHINA-ZH
      </div>
    
  </div>
</div>

    

    
  
    <div id="cover" style="background-image:url('https://pixelpig-1253685321.cos.ap-guangzhou.myqcloud.com/cover.jpg');"></div>
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js"></script>


<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
  




    
  </body>
</html>

